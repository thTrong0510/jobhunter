===== Chapter 3: Hello World với Spring REST ====

##1 - Hello World##

- Check code kết nối tới database mysql Đảm bảo rằng bạn đã cài đặt MySQL Workbench, và có tài khoản đăng nhập vào database.
//build.gradle.kts => nhấn chuột phải, chọn “Reload projects)
	Enable 2 dependencies là jpa và mysql -> khi enable 2 dependencies này -> cần phải cấu hình thêm thông tin kết nối xuống database nếu ko sẽ lỗi 

- thư viện spring-boot-devtools giúp tự động update reload dự án khi bấm lưu code

##2 - Cấu trúc dự án thực hành##

- Trong dự án này sử dụng 1 Built Tools là Gradle chứ ko pải maven là công cụ giúp built/chạy dự án 
	settings.gradle.kts: cung cấp tên dự án, một số thông tin bổ sung meta data
	build.gradle.kts: nói cho Gradle biết
		code ngôn ngữ gì, dịch code ntn
		chạy java version nào
		nơi nào kéo các thư viện về repositories {mavenCentral()} đây là kéo từ Maven Repository sau này nếu có 1 số thư viện tự code/private -> định nghĩa thêm vào đây 
		cuối cùng là định nghĩa những thư viện nào cần dùng
			actuator: kiểm tra hệ thống 
			data-jpa: giúp kết nối xuống database (ORM)
			security: login và phân quyền người dùng 
			các thư viện liên quan đến thymeleaf: làm chức năng gửi email 
			validation: validate dữ liệu 	
			starter-web: dùng để chạy server/ứng dụng lên 
			boot-devtools: khi bấm lưu code hệ thống/server sẽ tự restart lại 
			mysql-connector-j: giúp chạy được mysql trong ứng dụng 
			những cái test là liên quan đến viết test case 
	thư mục gradle/ giúp cấu hình sẵn (version của gradle, ...) khi kéo về đã cấu hình sẵn ko cần cài lại 

- thư mục src: 
+ main: thư mục viết code
	java: viết code java
		file main: nơi bắt đầu chạy dự án
	config: config security, json web token, filter với security
	repository: định nghĩa công cụ kết nối xuống database, những function muốn truy cập xuống database 
	service: là cầu nối từ controller gọi xuống service -> repository 
	domain: định nghĩa các model, actor, tale lưu vào database 
	controller: điều hướng trang, định nghĩa các route 
	resources: lưu các tài nguyên
	
+ test: viết test case

- các thư mục ẩn:
	.vscode: đây là thư mục được sinh ra để cấu hình cách thức chạy dự án từ file lauch.json file này được sinh ra khi bấm chạy chương trình ở dashboard 

	.gradle/bin: là 2 thư mục cần dùng của gradle làm sao để dịch code sẽ dịch code sang các file class vào thư mục bin hoặc sẽ lưu vào thư mục Build nếu dự án chưa có/ko có thư mục này thì chạy lệnh ./gradlew bootRun

- Những file có tiền tố "gradle" là công cụ build dự án, hiểu một cách đơn giản:
	+ quản lý các thư viện cài đặt
	+ dịch code/build/run 

	+ bao gồm: 
		buld.gradle.kts
		gradlew (gradlew.bat)
		settings.gradle.kts

- Gradle
	Giúp bạn: Dịch code java -> .class vì java Virtual Machine chạy file class (ngôn ngữ tự nhiên -> ngôn ngữ máy)
	Copy phần resource vào thư mục build
	Tạo file jar: triên khai dự án ntn
	Run test: test case 
	And more…
Về Gradle: https://www.youtube.com/watch?v=R6Z-Sxb837I

- Sử dụng gradle:
	Run dự án Spring Boot:
		gradle bootRun
		./gradle bootRun

	Build file jar: gradlew bootJar

	hiện tại đan sử dụng Gradle Koltin(dùng nhiều hơn) chứ ko pải Gradle Groovy 

- So sánh Gradle và các công cụ khác
Tham khảo:
https://stackoverflow.com/questions/45335874/gradle-what-is-the-benefit-if-i-switch-from-groovy-to-kotlin

Maven vs Gradle
https://gradle.org/maven-vs-gradle/

Về lý do tại sao tồn tại song song thư mục bin và thư mục build: (open issue)
https://github.com/redhat-developer/vscode-java/issues/2338

-> nếu có các lỗi khi chạy chương trình (ko pải lỗi cú pháp/lỗi code) -> đem dự án sang chạy ở IDE dùng cho java để nó config lại rồi đem về vscode chạy 


====Chapter 4 CRUD User với Restful API====

##I - Tổng quan các kiến thức sẽ học##

1. Nội dung sẽ học
- Phát triển REST APIs với Spring ( @RestController )
- Tìm hiểu các khái niệm liên quan tới REST APIs, JSON và giao thức HTTP
- Sử dụng Postman để test API

2. Vấn đề tồn đọng

Dưới góc nhìn của Developer (DEV)
Ví dụ học Spring MVC dự án laptopshop khi thực hiện hành động nào đó phía frontend nếu ko có sự can thiệp của javascript -> load lại trang 

Dưới góc nhìn của business (phân tích nghiệp vụ):
Ví dụ: Xây dựng ứng dụng Weather App 

Chắc chắn thông tin (dữ liệu) về Thời tiết, bạn sẽ không có, cần phụ thuộc vào bên thứ 3 cung cấp dịch vụ
(ví dụ Trung tâm Dự báo Khí tượng thủy văn Quốc gia)

Kiến trúc dự án:
My Weather App (Client) ---------> Weather Service (Server)

ở đây mình đi mua dữ liệu từ server của third party -> làm sao để kết nối giữa ứng dụng mình với server cung cấp dịch vụ/thông tin -> Làm sao để kết nối giữa client và server ?
	Sử dụng REST API thông qua giao thức http
	REST : REpresentational State Transfer

- Ngôn ngữ lập trình nào được sử dụng ?
REST không phụ thuộc vào ngôn ngữ lập trình
-> viết Client/Server bằng ngôn ngữ bạn muốn: Java, C#, PHP, Javascript, Python...

- Sử dụng định dạng data nào (data format) ?
JSON và XML được dùng
JSON sử dụng phổ biến nhất
JSON : JavaScript Object Notation

##II - JSON##

Tham khảo: https://www.w3schools.com/js/js_json_intro.asp

1. JSON là gì
- JavaScript Object Notation
- Là 1 định dạng để lưu trữ và trao đổi dữ liệu (mà không mã hóa gì hết / plain text)
- Được sử dụng ở nhiều ngôn ngữ khác nhau: Java, C#, Javascript ...

2. Cú pháp
Ví dụ về JSON:
{
"id": 1,
"name": "Hỏi Dân IT",
"age": 25,
"active": true
}

1 Json như thế này tương tự như 1 class của chúng ta - nhưng đối với Javascript thì gọi là Object 

- Sử dụng dấu { //data } để định nghĩa JSON
- Các thuộc tính được định nghĩa theo quy luật:  
	name: value (ngăn cách với nhau bởi dấu hai chấm)

Thuộc tính name luôn được bọc bởi " " (double quotes)

3. JSON values
- number
- string
- boolean
- nested JSON object
- Array
- null

//todo : json với nested object

4. JSON so với XML 
- đối với XML thì dùng các tag giống như html 
- đối với JSON {} -> giống ngôn ngữ tự nhiên hơn 

##III - API là gì##

Tham khảo: https://jsonplaceholder.typicode.com/

1. HTTP là gì
Tham khảo: https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview

HTTP Method ----------> CRUD Operation
POST ------------ Create a new entity
GET ------------- Read a list of entities or single entity
PUT ------------- Update an existing entity
DELETE ---------- Delete an existing entity

2. Cấu trúc HTTP Request
- Request line : method + URL
- Header variables
- Message body: json

3. API
API, hiểu đơn giản, là một đường link URL được định nghĩa tại backend
frontend ko tạo/viết được API 

Frontend sẽ gọi tới đường link URL được định nghĩa ở Backend này để lấy/sử dụng dữ liệu.

4. Status code
- khi dùng API không thể thiếu trạng thái phản hồi thông qua được biểu hiện thông qua các số 
Tham khảo: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

HTTP response status codes
	Informational responses (100 – 199)
	Successful responses (200 – 299)
	Redirection messages (300 – 399)
	Client error responses (400 – 499)
	Server error responses (500 – 599)

##IV - Test API với Postman##

Tham khảo:
https://jsonplaceholder.typicode.com/ trang fake API 

Test: URI https://jsonplaceholder.typicode.com/todos/1 (GET): các thông tin cần chú ý
	status code: 200 -> lấy thông tin thành công ko lỗi 
	kiểu data nên để dưới dạng JSON -> hiển thị đẹp hơn 
	Method: 
		GET: lấy tất cả nguồn tài nguyên 
		POST ...
API ở đây đơn giản là 1 đường link URL 


Lợi thế của postman so với browser:
- Đối với đường link URL trên nếu dán vào browser vẫn ra thông tin cần lấy nhưng chỉ dùng cho mỗi Method GET
- Đối với 1 API ngoài việc truyền vào URL có thể truyền thêm các tham số khác như: headers, ...

Để xem all thông tin của API thì bấm inspect + network + all + refresh + name({;}1) -> hiển thị bên phải là header + phần preview là thông tin GET về được 

##V - API##

1 - Test API trong Postman:
- khi test url + method thì trong controller phải có url ứng với method đó nếu ko nó sẽ ko hoạt động 

- Method GET: trường hợp create user ko dùng được method GET vì nó ko truyền được nhiều data, nếu dùng method GET phải truyền data trên URL (mà URL chỉ dài được 2048 kí tự -> hạn chế dữ liệu) + không an toàn thông tin 
	-> Method GET chỉ nếu dùng là gửi yêu cầu để lấy thông tin từ server về client ~ chứ ko nên dùng để gửi thông tin từ client đến server
	-> để gửi thông tin từ client -> server thì dùng method POST 
	Khi bấm send (dùng API) thì nó cũng như dùng với trình duyệt cũng sẽ chạy code của controller của URL đó 

- Method POST:
	Truyền Data kèm theo request: trong postman có 1 option (dưới điền url) là body đối với 1 lời gọi request ta có thể đính kèm dữ liệu thêm cho nó 

	chọn Body - raw - JSON: viết đối tượng người dùng muốn tạo hiện tại (model user: name, email, password)
		{"name": "Van Huy", "email":"vanhuy@gmail.com", "password":"123"}
	-> ở phía server làm sao để lấy được data này -> dùng Annotation @RequestBody
	
- Annotation @RequestBody
	Tài liệu: https://docs.spring.io/spring-framework/reference/6.0/web/webmvc/mvc-controller/ann-methods/requestbody.html
	cách dùng: bên trong tham số hàm controller đó dùng @RequestBody + Đối tượng -> nó sẽ mapping từ data trong postman đến đối tượng (tên thuộc tính trong JSON - tên trường thông tin của đối tượng) tức nó sẽ convert từ JSON -> kiểu dữ liệu đối tượng 
	Khi ko set ID (mặc định ID sẽ = 0 hoặc = null) -> đối với Spring nó chỉ có 1 hàm là save() nếu ID = 0 || null nó sẽ mặc định hiểu là Create nếu ID khác thì nó sẽ hiểu là Update

	Khi bấm send thay vì nhận 1 chuỗi String -> có thể nhận 1 đối tượng đã gửi lên (thông tin user lúc này sẽ khác so với thông tin user đã gửi lên = có thêm id) = cách thay dữ liệu trả về = 1 User 

	Tại sao chỉ cầm thêm @RequestBody đã có thể convert từ JSON -> User (gửi data lên server) và ngược lại (nhận thông tin từ server)
		Java JSON Data Binding
		Data binding là quá trình convert JSON data thành Java POJO (Java Object) hoặc ngược lại.
		Spring sử dụng Jackson Project (behind the scenes) đây là 1 thư viện được tự động kéo về khi cài thư viện spring-boot-starter-web 
		link xem thông tin về Jackson https://github.com/FasterXML/jackson
		link xem các thư viện trong spring-boot-starter-web: có Jackson https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-starters/spring-boot-starter-json/build.gradle

- Annotation @PathVariable
	Tài liệu: https://www.baeldung.com/spring-pathvariable
	Sửa lại URL: POST (CREATE): http://localhost:8080/user
	Làm chức năng xóa user by id: DELETE (Xóa): http://localhost:8080/user/${user-id}

##2 - Tổng Kết Về RESTful (Basic)##
- Chuẩn RESTful
Ứng với tác vụ CRUD:

GET (READ) - Đọc thông tin 
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET
	Được dùng để lấy data 
	không truyền data ở body
	Có thể truyền data ở url (ví dụ delete by id - @PathVariable)

POST (CREATE) - Tạo mới thông tin 
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST
	Được dùng để truyền data lên Server 
	Có thể truyền data ở body request (@RequestBody)

PUT/PATCH  (UPDATE) - Cập nhật thông tin
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH
	Được dùng để truyền data lên Server 
	Có thể truyền data ở body request (@RequestBody)
	PUT: cập nhật ghi đè lại nguyên đối tượng
	PATCH: cập nhật ghi đè một số trường thông tin 
	

DELETE (DELETE) - Xóa thông tin
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE
	Được dùng để xóa data 
	Có thể truyền data ở url (ví dụ delete by id - @PathVariable)

##3 - Spring Data Rest Project (Extra)##
Tài liệu: https://spring.io/projects/spring-data-rest

1.Spring Data Rest
Tự động tạo endpoint (api) ứng với domain (model) mà không cần viết code.
	Ví dụ, bạn có Entity là User, nó sẽ tự động tạo : 
	GET /users
	POST /users …
Có thể tùy chỉnh (customize) để phục vụ API của JPA, như paging, sorting…

2. So sánh Spring Data Rest và @RestController  
Nhược điểm của đứa này, là ưu điểm của đứa kia :v
Spring Data Rest: code ngắn, phù hợp để phát triển ứng dụng một cách nhanh nhất có thể (vì code rất ít). Vì vậy, phù hợp để giải quyết tác vụ CRUD đơn giản.
@RestController  :  code dài hơn. 100% kiểm soát code 


====Chapter 5: Response Entity====
Xử lý phản hồi của API với Response Entity

##I - Tại sao cần Response Entity##

Mô hình đang thực hiện: client -> server
Cụ thể: client (browser/postman) gửi request (yêu cầu)  tới server (java) thông qua RESTful APIs

Server (java) gửi response (phản hồi) về cho client

Hiện tại, phản hồi (response) đang ở dạng text, hoặc JSON object

Để các hệ thống nói chuyện với nhau 1 cách đầy đủ nhất, 1 lời phản hồi (response) sẽ gồm:
	- Thông tin header (ví dụ bạn muốn dùng cookies chẳng hạn)
	- Thông tin status (http status) : mã phản hồi
	- Thông tin body (nếu có) : data phản hồi, thông thường dưới dạng JSON

##II. Spring ResponseEntity##
Tài liệu: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html

- Kế thừa HttpEntity, với bổ sung http status

Minh họa một vài cách dùng thông dụng:
- trả về mình status
ResponseEntity.status(HttpStatus.Ok).body(null);

- trả về Status và headers:
ResponseEntity.status(HttpStatus.Ok).headers(Instance_of_HttpHeaders).build();

- trả về Status, headers và body:
ResponseEntity.status(HttpStatus.Ok).headers(Instance_of_HttpHeaders)
.body(Instance_of_object_send_back_to_client);

##II - HTTP Status Code hay dùng##
Tài liệu: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

Mã lỗi ám chỉ request thành công:
200 - request succeeded (hay dùng cho method GET/PUT/DELETE)
201 - request created a resource (hay dùng cho method POST)
204 - no content to return (dùng khi bạn muốn thông báo không có data ở phản hồi)

202 - Accepted (the request has been accepted for processing, but the processing has not been completed): dùng khi bạn chạy job/background task và muốn gửi phản hồi cho client

Mã lỗi ám chỉ request thất bại (lỗi do client):
400 - Bad request (lỗi exception, validate...)
401 - Unauthorized (unauthenticated): bạn chưa đăng nhập, có nghĩa rằng bạn cần login thành công thì mới có quyền sử dụng endpoint (API)
403 - Forbidden (unauthorized): bạn đã đăng nhập thành công, tuy nhiên, bạn không có quyền hạn (authorization) để thực hiện tác vụ này
404 - Resource not found : lỗi huyền thoại cmnr :v
405 - Method not supported : check cho đúng method khi sử dụng với endpoint

415 - Media not supported: bạn cần truyền đúng định dạng format mà server/client mong muốn. Ví dụ, bạn không thể dùng JSON để gửi file lên 
server (cần dùng formData)

Mã lỗi ám chỉ request thất bại (lỗi do server):
500 - Internal Server error: lỗi xảy ra bên trong Server, cần đọc logs để biết lỗi gì (exception, bugs...)
503 - Service Unavailable : server ngỏm (không chạy) nên không có sẵn để sử dụng
504 - Gateway Timeout : server (có thể) không ngỏm, cơ mà không phản hồi trong thời gian quy định (quá lâu để phản hồi)

1 - Update Status Code & Body cho APIs

- Đọc code: của class ResponseEntity -> là 1 class cần truyên vào thêm 1 đối tượng/generate (kiểu template trong C++) + keyword builder
- sử dụng ResponseEntity: đổi các kiểu dữ liệu trả về trong Controller = ResponseEntity<T> -> return về có 2 cách:
	+ new ResponseEntity<T>(body, header, status code)... (dùng constructor)
	+ hoặc dùng trực tiếp ResponseEntity.staticMethod (* dùng cách này) đây là 1 design pattern (builder pattern): Gọi trức tiếp đối tượng và sử dụng các static method -> được gợi ý + tên method có ý nghĩa  

	return ResponseEntity.status(HttpStatus.CREATED).body(null);
	Phần status có thể hash code 201 những nên dùng như trên ~ 201 nếu truy ngược lại 
	Phần body chỉ được truyền vào giá trị của đối tượng T
	Về phần headers -> đợi đến cookies 

return ResponseEntity.ok(user); sẽ tương đương với return ResponseEntity.status(HttpStatus.CREATED).body(user);
	-> hàm ok return về ok().body(T) (ok() -> HttpStatus.OK + body(T)) -> done

Đối với Delete -> nên trả ra status code là 204 - no content + nếu muốn ko trả ra đối tượng ở Body dùng ResponseEntity<Void>




Tài liệu: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html

//responseEntity<void> nếu set body = null

//lưu ý: endpoint nên viết số nhiều
Ví dụ => user => users

//update cho tất cả CRUD endpoint

2 - Giải thích code (Extra)

//tham khảo jhipster
https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/blob/master/src/main/java/com/mycompany/myapp/web/rest/DepartmentResource.java?ref_type=heads


//builder pattern là 1 design pattern 
https://springframework.guru/gang-of-four-design-patterns/builder-pattern/

====Chapter 6: Xử Lý Exception====

##I - Throw Exception##

https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/blob/master/src/main/java/com/mycompany/myapp/web/rest/DepartmentResource.java?ref_type=heads

//todo: // fetch user by id
Xử ký ngoại lệ khi người dùng gửi lên sai thông tin thay vì việc ném ra massage exception mặc định -> customize là 1 exception do mình tự định nghĩa ko dùng hàm có sẵn 
	- Tạo 1 class kế thừa lại Exception
	- Tạo 1 class kế thừa lại RuntimeException
Java có 2 loại Exception: checked Exception (lỗi dev pải handle: như người dùng truyền lên sai dữ liệu, ...) và unchecked Exception (null pointer exception)

Có 2 cách ném Exception: 
	ném exception ngay tại đầu hàm (khi truyền vào dữ liệu ko hợp lệ -> xử lý throw exception được) 
	try..catch (khi truyền vào dữ liệu ko hợp lệ -> ko xử lý throw exception được) -> throw exception mặc định
	-> 2 trường hợp này dùng với throw -> nó sẽ chỉ hiển thị lỗi ở Terminal ko hiển thị ra màn hình được -> cần sử dụng cái nào trả ra ResponseEntity(customize phần pản hồi ra client)

	@ExceptionHandler dùng để trang trí cho 1 hàm (như 1 listener) mỗi lần xảy ra ngoại lệ (khi throw ra exception nào mà exception đó được gán vào value của @ExceptionHandler) -> sẽ chạy vào hàm này + ResponseEntity để trả customized exception cho Client 
		@ExceptionHandler(value = IdInvalidException.class)		
		public ResponseEntity<String> handleIdException(IdInvalidException idInvalidException) {	
			return ResponseEntity.badRequest().body(idInvalidException.getMessage());
		}
	khi dùng dùng @Annotation này -> khi gặp lỗi cần throw trực tiếp thì nó mới chạy vào hàm xử lý của Annotation này - nếu dùng try..catch thì nó sẽ ko chạy vào
	Khi throw trực tiếp (ko dùn try..catch) thì đầu hàm phải có throws ...Exception nếu ko sẽ bị lỗi 

Tồn đọng: khi khai báo như trên bên trong UserController.java
(1) phạm vi hoạt động của function(@ExceptionHandler) chỉ nằm trong UserController -> cần định nghĩa khác để linh hoạt hơn
(2) hiện tại khi tham số truyền vào là 1 chuỗi String -> nó sẽ ko chạy vào throw bên trong hàm mà sẽ throw ở ngoài hàm = exception mặc định -> cần xử lý bên ngoài bắt ngoại lệ bên ngoài controller đó tức là bug ko nằm trong phần body hàm mà xảy ra lúc convert ở các tham số khi truyền vào của hàm
	Cách 1: valid ở frontend 
	Cách 2: chuyển kiểu dữ liệu thành String -> valid ở backend 

			Mô hình Spring Request Response 
client --request--> controller 
				----> local Exception (khai báo @ExceptionHandler bên trong 1 file java) --crash--> client
				----> globle Exception 
	local Exception -> chỉ dùng được trong 1 file 
	-> cần chuyển nó ra thành globle Exception để dùng trong nhiều trường hợp để làm thì ta có 1 khái niệm gọi là AOP là 1 khái niệm chia cắt ứng dụng thành các thành phần ko quan hệ với nhau (các thành phần độc lập)

Giới thiệu về AOP
https://docs.spring.io/spring-framework/reference/core/aop.html

Tham khảo: https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/tree/master/src/main/java/com/mycompany/myapp?ref_type=heads
-> trong github này họ làm cho logging aop/logging trong này họ dùng các Annotation rất đặc biệt như @Aspect, @PointCut, ... dự án này sẽ dùng ControllerAdvice là 1 ứng dụng của AOP để can thiệp vào quá trình xử lý trước khi trả về phản hồi cho người dùng + ko tập trung code tại 1 file mà nó sẽ chịu trách nhiệm tất cả các file còn lại 
				

Xử lý (1):  @ControllerAdvice

-  Spring @ControllerAdvice https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html

Được giới thiệu từ version Spring Framework 3.2
Xử lý @ExceptionHandler, @InitBinder, or @ModelAttribute được chia sẻ tại tất cả controller trong ứng dụng MVC
Cũng có thể làm tương tự cho RESTful, tuy nhiên cần @ResponseBody

@ResponseBody giúp convert Response trả về dưới dạng JSON
Ví dụ 1: Xử lý với MVC
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(value = Exception.class)
   public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {
        ModelAndView mav = new ModelAndView();
        mav.addObject("exception", e);
        mav.addObject("url", req.getRequestURL());
        mav.setViewName("error");
        return mav;
    }
}
-> cấu hình và response ra view cho người dùng

  Ví dụ 2: Xử lý với RESTful  
// Handle custom exceptions across the application
    @ExceptionHandler(CustomException.class)
    @ResponseBody //phần cần thêm để có thể sử dụng ResponseEntity<T> phía dưới nếu k có ko dùng được  
    public ResponseEntity<?> handleCustomException(CustomException ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
                HttpStatus.BAD_REQUEST.value(),
                ex.getMessage(),
                request.getDescription(false));
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

Có 1 cách nữa để sử dụng với RESTFul, là sử dụng  @RestControllerAdvice

@RestControllerAdvice được giới thiệu từ version 4.3

https://docs.spring.io/spring-framework/docs/4.3.9.RELEASE/javadoc-api/org/springframework/web/bind/annotation/RestControllerAdvice.html

So sánh @RestControllerAdvice và @ControllerAdvice: 
https://stackoverflow.com/a/43124517

@RestControllerAdvice = @ControllerAdvice + @ResponseBody

@ControllerAdvice dùng được cho Spring MVC + Restful API (kèm theo dùng @ResponseBody)
@RestControllerAdvice chỉ dùng cho Restful API (ra đời sau)
	
2 Annotation này sẽ can thiệp vào ném ra Exception @ExceptionHandler, khởi tạo giá trị @InitBinder, gán giá trị cho ModelAttribute @ModelAttribute -> can thiệp vào quá trình xử lý đây cũng là 1 Ứng dụng của AOP

##II - Format Response before Sending (Part 1)##

Tài liệu: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseBodyAdvice.html

1.Ví dụ về API trong thực tế

Việc viết API này -> phục vụ cho dự án + đối tác (đồng nhất theo 1 chuẩn)

https://developers.momo.vn/v2/#/docs/query_status

Một kết quả trả ra của API, luôn cần có:
Status code : 200, 201, …
Message : miêu tả nếu có
Data : nếu có

Mỗi 1 công ty có 1 quy định khác nhau về format của phản hồi, tuy nhiên, tối thiểu API cần cung cấp 3 thông tin trên

Mục tiêu: Trả về response theo format định sẵn
Trường hợp thành công:
{
  statusCode: " ", //200 404
  message: " ",
  data: " "
}

Ví dụ:
{
    "statusCode": 201,
    "message": "User Login",
    "data": {
        "access_token": "",
        "user": { }
    }
}

Trường hợp lỗi : 
{
    "message": " ",
    "error": " "
    "statusCode":" ",
}
Ví dụ: {
    "message": "Username/password không hợp lệ!",
    "error": "Unauthorized",
    "statusCode": 401
}


2.Format Response

Cách 1: sử dụng local với ResponseEntity -> gửi dữ liệu về client
https://stackoverflow.com/a/44840010
-> nhược điểm: ko linh động cần thêm thủ công -> có bao nhièu API pải thêm bấy nhiêu ResponseEntity

Cách 2: sử dụng global với Controller Advice
https://stackoverflow.com/a/52104852
-> linh động hơn ~ như xử lý Exception 

Bước 1: Định nghĩa format object

public class RestResponse<T> {
    private int statusCode;
    private String error;

    // message có thể là string, hoặc arrayList
    private Object message;
    private T data;

}


Bước 2: Sử dụng ControllerAdvice
https://stackoverflow.com/a/51551663

@ControllerAdvice
public class FormatRestResponse implements ResponseBodyAdvice<Object> {
	
//đây là 2 method buộc override của interface ResponseBodyAdvice
    @Override
    public boolean supports(
        MethodParameter returnType, 
        Class converterType
    ) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(
    Object body, 
    MethodParameter returnType, 
    MediaType selectedContentType,
    Class selectedConverterType,
    ServerHttpRequest request, 
    ServerHttpResponse response
) {
    
                // Check if the status code represents an error
        if (status >= 400) {
            //case error
        } else {
            //case success
        }
    }
}

- ở hàm supports có ý nghĩa cấu hình khi nào muốn ghi đè - khi nào format phản hồi của API 
	-> return về true bất cứ phản hồi nào cũng ghi đè
	-> sau này muốn check cho từng controller thì ghi logic vào đây
	
	-> return false thì nó sẽ ko format 

- hàm beforeBodyWrite được chạy khi hàm supports trả về true 
	Object body: là phản hồi chưa format
	request: lời gọi từ client -> server 
	response: thông tin trả về từ server -> client 
	-> muốn lấy trạng thái của pản hồi pải thông qua response
	
	Nhưng đối với response thông thường -> sẽ không lấy về được status code cần ép kiểu nó về HttpServletResponse 
	HttpServletResponse servletResponse = ((ServletServerHttpResponse)response).getServletResponse();

- cấu hình lại phần response:
	int status = servletResponse.getStatus();

        RestResponse<Object> restResponse = new RestResponse<Object>();
        restResponse.setStatusCode(status);
        if (status >= 400) {
            // case error
            restResponse.setError("CALL API FAIL");
            restResponse.setMessage(body);
        } else {
            // case success
            restResponse.setData(body);
            restResponse.setMessage("CALL API SUCCESS");
        }
        return restResponse;

Tới đây nếu test api truyền sai dữ liệu lên -> vẫn chưa hoạt động đúng vì nó sẽ chạy ResponseBodyAdvice<Object> trong FormatRestResponse.java trước khi chạy vào GlobalException.java có 2 cách để xử lý thứ tự:
	- dùng Annotation Order 

- Khi cấu hình xong class này thì mọi phản hồi từ Server -> Client để sẽ chạy vào đây chứ ko phải phần return của từng API nữa 

3 - Cấu hình Phần Globla Exception + Global Response: dùng @ControllerAdvice, @ResponseBody || @RestControllerAdvice
- Khi gọi API thành công -> chạy vào controller -> đến return ResponseEntity.status(HttpStatus.OK).body(this.userService.fetchUserById(id)); -> chạy sang FormatRestResponse(globla Response chạy qa 2 hàm supports -> beforeBodyWrite) -> response về cho client

- Khi gọi ko thành công -> chạy vào throw new IdInvalidException("user ko ton tai"); -> chạy vào class IdInvalidException -> chạy vào GlobalException.java -> FormatRestResponse (Global Response chạy qa 2 hàm supports -> beforeBodyWrite) -> response về cho client

** tất cả test cho API /users/{id} với kiểu kiểm tra đơn giản là id có tồn tại hay ko **









	















