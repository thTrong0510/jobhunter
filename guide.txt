===== Chapter 3: Hello World với Spring REST ====

##1 - Hello World##

- Check code kết nối tới database mysql Đảm bảo rằng bạn đã cài đặt MySQL Workbench, và có tài khoản đăng nhập vào database.
//build.gradle.kts => nhấn chuột phải, chọn “Reload projects)
	Enable 2 dependencies là jpa và mysql -> khi enable 2 dependencies này -> cần phải cấu hình thêm thông tin kết nối xuống database nếu ko sẽ lỗi 

- thư viện spring-boot-devtools giúp tự động update reload dự án khi bấm lưu code

##2 - Cấu trúc dự án thực hành##

- Trong dự án này sử dụng 1 Built Tools là Gradle chứ ko pải maven là công cụ giúp built/chạy dự án 
	settings.gradle.kts: cung cấp tên dự án, một số thông tin bổ sung meta data
	build.gradle.kts: nói cho Gradle biết
		code ngôn ngữ gì, dịch code ntn
		chạy java version nào
		nơi nào kéo các thư viện về repositories {mavenCentral()} đây là kéo từ Maven Repository sau này nếu có 1 số thư viện tự code/private -> định nghĩa thêm vào đây 
		cuối cùng là định nghĩa những thư viện nào cần dùng
			actuator: kiểm tra hệ thống 
			data-jpa: giúp kết nối xuống database (ORM)
			security: login và phân quyền người dùng 
			các thư viện liên quan đến thymeleaf: làm chức năng gửi email 
			validation: validate dữ liệu 	
			starter-web: dùng để chạy server/ứng dụng lên 
			boot-devtools: khi bấm lưu code hệ thống/server sẽ tự restart lại 
			mysql-connector-j: giúp chạy được mysql trong ứng dụng 
			những cái test là liên quan đến viết test case 
	thư mục gradle/ giúp cấu hình sẵn (version của gradle, ...) khi kéo về đã cấu hình sẵn ko cần cài lại 

- thư mục src: 
+ main: thư mục viết code
	java: viết code java
		file main: nơi bắt đầu chạy dự án
	config: config security, json web token, filter với security
	repository: định nghĩa công cụ kết nối xuống database, những function muốn truy cập xuống database 
	service: là cầu nối từ controller gọi xuống service -> repository 
	domain: định nghĩa các model, actor, tale lưu vào database 
	controller: điều hướng trang, định nghĩa các route 
	resources: lưu các tài nguyên
	
+ test: viết test case

- các thư mục ẩn:
	.vscode: đây là thư mục được sinh ra để cấu hình cách thức chạy dự án từ file lauch.json file này được sinh ra khi bấm chạy chương trình ở dashboard 

	.gradle/bin: là 2 thư mục cần dùng của gradle làm sao để dịch code sẽ dịch code sang các file class vào thư mục bin hoặc sẽ lưu vào thư mục Build nếu dự án chưa có/ko có thư mục này thì chạy lệnh ./gradlew bootRun

- Những file có tiền tố "gradle" là công cụ build dự án, hiểu một cách đơn giản:
	+ quản lý các thư viện cài đặt
	+ dịch code/build/run 

	+ bao gồm: 
		buld.gradle.kts
		gradlew (gradlew.bat)
		settings.gradle.kts

- Gradle
	Giúp bạn: Dịch code java -> .class vì java Virtual Machine chạy file class (ngôn ngữ tự nhiên -> ngôn ngữ máy)
	Copy phần resource vào thư mục build
	Tạo file jar: triên khai dự án ntn
	Run test: test case 
	And more…
Về Gradle: https://www.youtube.com/watch?v=R6Z-Sxb837I

- Sử dụng gradle:
	Run dự án Spring Boot:
		gradle bootRun
		./gradle bootRun

	Build file jar: gradlew bootJar

	hiện tại đan sử dụng Gradle Koltin(dùng nhiều hơn) chứ ko pải Gradle Groovy 

- So sánh Gradle và các công cụ khác
Tham khảo:
https://stackoverflow.com/questions/45335874/gradle-what-is-the-benefit-if-i-switch-from-groovy-to-kotlin

Maven vs Gradle
https://gradle.org/maven-vs-gradle/

Về lý do tại sao tồn tại song song thư mục bin và thư mục build: (open issue)
https://github.com/redhat-developer/vscode-java/issues/2338

-> nếu có các lỗi khi chạy chương trình (ko pải lỗi cú pháp/lỗi code) -> đem dự án sang chạy ở IDE dùng cho java để nó config lại rồi đem về vscode chạy 


====Chapter 4 CRUD User với Restful API====

##I - Tổng quan các kiến thức sẽ học##

1. Nội dung sẽ học
- Phát triển REST APIs với Spring ( @RestController )
- Tìm hiểu các khái niệm liên quan tới REST APIs, JSON và giao thức HTTP
- Sử dụng Postman để test API

2. Vấn đề tồn đọng

Dưới góc nhìn của Developer (DEV)
Ví dụ học Spring MVC dự án laptopshop khi thực hiện hành động nào đó phía frontend nếu ko có sự can thiệp của javascript -> load lại trang 

Dưới góc nhìn của business (phân tích nghiệp vụ):
Ví dụ: Xây dựng ứng dụng Weather App 

Chắc chắn thông tin (dữ liệu) về Thời tiết, bạn sẽ không có, cần phụ thuộc vào bên thứ 3 cung cấp dịch vụ
(ví dụ Trung tâm Dự báo Khí tượng thủy văn Quốc gia)

Kiến trúc dự án:
My Weather App (Client) ---------> Weather Service (Server)

ở đây mình đi mua dữ liệu từ server của third party -> làm sao để kết nối giữa ứng dụng mình với server cung cấp dịch vụ/thông tin -> Làm sao để kết nối giữa client và server ?
	Sử dụng REST API thông qua giao thức http
	REST : REpresentational State Transfer

- Ngôn ngữ lập trình nào được sử dụng ?
REST không phụ thuộc vào ngôn ngữ lập trình
-> viết Client/Server bằng ngôn ngữ bạn muốn: Java, C#, PHP, Javascript, Python...

- Sử dụng định dạng data nào (data format) ?
JSON và XML được dùng
JSON sử dụng phổ biến nhất
JSON : JavaScript Object Notation

##II - JSON##

Tham khảo: https://www.w3schools.com/js/js_json_intro.asp

1. JSON là gì
- JavaScript Object Notation
- Là 1 định dạng để lưu trữ và trao đổi dữ liệu (mà không mã hóa gì hết / plain text)
- Được sử dụng ở nhiều ngôn ngữ khác nhau: Java, C#, Javascript ...

2. Cú pháp
Ví dụ về JSON:
{
"id": 1,
"name": "Hỏi Dân IT",
"age": 25,
"active": true
}

1 Json như thế này tương tự như 1 class của chúng ta - nhưng đối với Javascript thì gọi là Object 

- Sử dụng dấu { //data } để định nghĩa JSON
- Các thuộc tính được định nghĩa theo quy luật:  
	name: value (ngăn cách với nhau bởi dấu hai chấm)

Thuộc tính name luôn được bọc bởi " " (double quotes)

3. JSON values
- number
- string
- boolean
- nested JSON object
- Array
- null

//todo : json với nested object

4. JSON so với XML 
- đối với XML thì dùng các tag giống như html 
- đối với JSON {} -> giống ngôn ngữ tự nhiên hơn 

##III - API là gì##

Tham khảo: https://jsonplaceholder.typicode.com/

1. HTTP là gì
Tham khảo: https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview

HTTP Method ----------> CRUD Operation
POST ------------ Create a new entity
GET ------------- Read a list of entities or single entity
PUT ------------- Update an existing entity
DELETE ---------- Delete an existing entity

2. Cấu trúc HTTP Request
- Request line : method + URL
- Header variables
- Message body: json

3. API
API, hiểu đơn giản, là một đường link URL được định nghĩa tại backend
frontend ko tạo/viết được API 

Frontend sẽ gọi tới đường link URL được định nghĩa ở Backend này để lấy/sử dụng dữ liệu.

4. Status code
- khi dùng API không thể thiếu trạng thái phản hồi thông qua được biểu hiện thông qua các số 
Tham khảo: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

HTTP response status codes
	Informational responses (100 – 199)
	Successful responses (200 – 299)
	Redirection messages (300 – 399)
	Client error responses (400 – 499)
	Server error responses (500 – 599)

##IV - Test API với Postman##

Tham khảo:
https://jsonplaceholder.typicode.com/ trang fake API 

Test: URI https://jsonplaceholder.typicode.com/todos/1 (GET): các thông tin cần chú ý
	status code: 200 -> lấy thông tin thành công ko lỗi 
	kiểu data nên để dưới dạng JSON -> hiển thị đẹp hơn 
	Method: 
		GET: lấy tất cả nguồn tài nguyên 
		POST ...
API ở đây đơn giản là 1 đường link URL 


Lợi thế của postman so với browser:
- Đối với đường link URL trên nếu dán vào browser vẫn ra thông tin cần lấy nhưng chỉ dùng cho mỗi Method GET
- Đối với 1 API ngoài việc truyền vào URL có thể truyền thêm các tham số khác như: headers, ...

Để xem all thông tin của API thì bấm inspect + network + all + refresh + name({;}1) -> hiển thị bên phải là header + phần preview là thông tin GET về được 

##V - API##

1 - Test API trong Postman:
- khi test url + method thì trong controller phải có url ứng với method đó nếu ko nó sẽ ko hoạt động 

- Method GET: trường hợp create user ko dùng được method GET vì nó ko truyền được nhiều data, nếu dùng method GET phải truyền data trên URL (mà URL chỉ dài được 2048 kí tự -> hạn chế dữ liệu) + không an toàn thông tin 
	-> Method GET chỉ nếu dùng là gửi yêu cầu để lấy thông tin từ server về client ~ chứ ko nên dùng để gửi thông tin từ client đến server
	-> để gửi thông tin từ client -> server thì dùng method POST 
	Khi bấm send (dùng API) thì nó cũng như dùng với trình duyệt cũng sẽ chạy code của controller của URL đó 

- Method POST:
	Truyền Data kèm theo request: trong postman có 1 option (dưới điền url) là body đối với 1 lời gọi request ta có thể đính kèm dữ liệu thêm cho nó 

	chọn Body - raw - JSON: viết đối tượng người dùng muốn tạo hiện tại (model user: name, email, password)
		{"name": "Van Huy", "email":"vanhuy@gmail.com", "password":"123"}
	-> ở phía server làm sao để lấy được data này -> dùng Annotation @RequestBody
	
- Annotation @RequestBody
	Tài liệu: https://docs.spring.io/spring-framework/reference/6.0/web/webmvc/mvc-controller/ann-methods/requestbody.html
	cách dùng: bên trong tham số hàm controller đó dùng @RequestBody + Đối tượng -> nó sẽ mapping từ data trong postman đến đối tượng (tên thuộc tính trong JSON - tên trường thông tin của đối tượng) tức nó sẽ convert từ JSON -> kiểu dữ liệu đối tượng 
	Khi ko set ID (mặc định ID sẽ = 0 hoặc = null) -> đối với Spring nó chỉ có 1 hàm là save() nếu ID = 0 || null nó sẽ mặc định hiểu là Create nếu ID khác thì nó sẽ hiểu là Update

	Khi bấm send thay vì nhận 1 chuỗi String -> có thể nhận 1 đối tượng đã gửi lên (thông tin user lúc này sẽ khác so với thông tin user đã gửi lên = có thêm id) = cách thay dữ liệu trả về = 1 User 

	Tại sao chỉ cầm thêm @RequestBody đã có thể convert từ JSON -> User (gửi data lên server) và ngược lại (nhận thông tin từ server)
		Java JSON Data Binding
		Data binding là quá trình convert JSON data thành Java POJO (Java Object) hoặc ngược lại.
		Spring sử dụng Jackson Project (behind the scenes) đây là 1 thư viện được tự động kéo về khi cài thư viện spring-boot-starter-web 
		link xem thông tin về Jackson https://github.com/FasterXML/jackson
		link xem các thư viện trong spring-boot-starter-web: có Jackson https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-starters/spring-boot-starter-json/build.gradle

- Annotation @PathVariable
	Tài liệu: https://www.baeldung.com/spring-pathvariable
	Sửa lại URL: POST (CREATE): http://localhost:8080/user
	Làm chức năng xóa user by id: DELETE (Xóa): http://localhost:8080/user/${user-id}

##2 - Tổng Kết Về RESTful (Basic)##
- Chuẩn RESTful
Ứng với tác vụ CRUD:

GET (READ) - Đọc thông tin 
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET
	Được dùng để lấy data 
	không truyền data ở body
	Có thể truyền data ở url (ví dụ delete by id - @PathVariable)

POST (CREATE) - Tạo mới thông tin 
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST
	Được dùng để truyền data lên Server 
	Có thể truyền data ở body request (@RequestBody)

PUT/PATCH  (UPDATE) - Cập nhật thông tin
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH
	Được dùng để truyền data lên Server 
	Có thể truyền data ở body request (@RequestBody)
	PUT: cập nhật ghi đè lại nguyên đối tượng
	PATCH: cập nhật ghi đè một số trường thông tin 
	

DELETE (DELETE) - Xóa thông tin
	https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE
	Được dùng để xóa data 
	Có thể truyền data ở url (ví dụ delete by id - @PathVariable)

##3 - Spring Data Rest Project (Extra)##
Tài liệu: https://spring.io/projects/spring-data-rest

1.Spring Data Rest
Tự động tạo endpoint (api) ứng với domain (model) mà không cần viết code.
	Ví dụ, bạn có Entity là User, nó sẽ tự động tạo : 
	GET /users
	POST /users …
Có thể tùy chỉnh (customize) để phục vụ API của JPA, như paging, sorting…

2. So sánh Spring Data Rest và @RestController  
Nhược điểm của đứa này, là ưu điểm của đứa kia :v
Spring Data Rest: code ngắn, phù hợp để phát triển ứng dụng một cách nhanh nhất có thể (vì code rất ít). Vì vậy, phù hợp để giải quyết tác vụ CRUD đơn giản.
@RestController  :  code dài hơn. 100% kiểm soát code 


====Chapter 5: Response Entity====
Xử lý phản hồi của API với Response Entity

##I - Tại sao cần Response Entity##

Mô hình đang thực hiện: client -> server
Cụ thể: client (browser/postman) gửi request (yêu cầu)  tới server (java) thông qua RESTful APIs

Server (java) gửi response (phản hồi) về cho client

Hiện tại, phản hồi (response) đang ở dạng text, hoặc JSON object

Để các hệ thống nói chuyện với nhau 1 cách đầy đủ nhất, 1 lời phản hồi (response) sẽ gồm:
	- Thông tin header (ví dụ bạn muốn dùng cookies chẳng hạn)
	- Thông tin status (http status) : mã phản hồi
	- Thông tin body (nếu có) : data phản hồi, thông thường dưới dạng JSON

##II. Spring ResponseEntity##
Tài liệu: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html

- Kế thừa HttpEntity, với bổ sung http status

Minh họa một vài cách dùng thông dụng:
- trả về mình status
ResponseEntity.status(HttpStatus.Ok).body(null);

- trả về Status và headers:
ResponseEntity.status(HttpStatus.Ok).headers(Instance_of_HttpHeaders).build();

- trả về Status, headers và body:
ResponseEntity.status(HttpStatus.Ok).headers(Instance_of_HttpHeaders)
.body(Instance_of_object_send_back_to_client);

##II - HTTP Status Code hay dùng##
Tài liệu: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

Mã lỗi ám chỉ request thành công:
200 - request succeeded (hay dùng cho method GET/PUT/DELETE)
201 - request created a resource (hay dùng cho method POST)
204 - no content to return (dùng khi bạn muốn thông báo không có data ở phản hồi)

202 - Accepted (the request has been accepted for processing, but the processing has not been completed): dùng khi bạn chạy job/background task và muốn gửi phản hồi cho client

Mã lỗi ám chỉ request thất bại (lỗi do client):
400 - Bad request (lỗi exception, validate...)
401 - Unauthorized (unauthenticated): bạn chưa đăng nhập, có nghĩa rằng bạn cần login thành công thì mới có quyền sử dụng endpoint (API)
403 - Forbidden (unauthorized): bạn đã đăng nhập thành công, tuy nhiên, bạn không có quyền hạn (authorization) để thực hiện tác vụ này
404 - Resource not found : lỗi huyền thoại cmnr :v
405 - Method not supported : check cho đúng method khi sử dụng với endpoint

415 - Media not supported: bạn cần truyền đúng định dạng format mà server/client mong muốn. Ví dụ, bạn không thể dùng JSON để gửi file lên 
server (cần dùng formData)

Mã lỗi ám chỉ request thất bại (lỗi do server):
500 - Internal Server error: lỗi xảy ra bên trong Server, cần đọc logs để biết lỗi gì (exception, bugs...)
503 - Service Unavailable : server ngỏm (không chạy) nên không có sẵn để sử dụng
504 - Gateway Timeout : server (có thể) không ngỏm, cơ mà không phản hồi trong thời gian quy định (quá lâu để phản hồi)

1 - Update Status Code & Body cho APIs

- Đọc code: của class ResponseEntity -> là 1 class cần truyên vào thêm 1 đối tượng/generate (kiểu template trong C++) + keyword builder
- sử dụng ResponseEntity: đổi các kiểu dữ liệu trả về trong Controller = ResponseEntity<T> -> return về có 2 cách:
	+ new ResponseEntity<T>(body, header, status code)... (dùng constructor)
	+ hoặc dùng trực tiếp ResponseEntity.staticMethod (* dùng cách này) đây là 1 design pattern (builder pattern): Gọi trức tiếp đối tượng và sử dụng các static method -> được gợi ý + tên method có ý nghĩa  

	return ResponseEntity.status(HttpStatus.CREATED).body(null);
	Phần status có thể hash code 201 những nên dùng như trên ~ 201 nếu truy ngược lại 
	Phần body chỉ được truyền vào giá trị của đối tượng T
	Về phần headers -> đợi đến cookies 

return ResponseEntity.ok(user); sẽ tương đương với return ResponseEntity.status(HttpStatus.CREATED).body(user);
	-> hàm ok return về ok().body(T) (ok() -> HttpStatus.OK + body(T)) -> done

Đối với Delete -> nên trả ra status code là 204 - no content + nếu muốn ko trả ra đối tượng ở Body dùng ResponseEntity<Void>




Tài liệu: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html

//responseEntity<void> nếu set body = null

//lưu ý: endpoint nên viết số nhiều
Ví dụ => user => users

//update cho tất cả CRUD endpoint

2 - Giải thích code (Extra)

//tham khảo jhipster
https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/blob/master/src/main/java/com/mycompany/myapp/web/rest/DepartmentResource.java?ref_type=heads


//builder pattern là 1 design pattern 
https://springframework.guru/gang-of-four-design-patterns/builder-pattern/

====Chapter 6: Xử Lý Exception====

##I - Throw Exception##

https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/blob/master/src/main/java/com/mycompany/myapp/web/rest/DepartmentResource.java?ref_type=heads

//todo: // fetch user by id
Xử ký ngoại lệ khi người dùng gửi lên sai thông tin thay vì việc ném ra massage exception mặc định -> customize là 1 exception do mình tự định nghĩa ko dùng hàm có sẵn 
	- Tạo 1 class kế thừa lại Exception
	- Tạo 1 class kế thừa lại RuntimeException
Java có 2 loại Exception: checked Exception (lỗi dev pải handle: như người dùng truyền lên sai dữ liệu, ...) và unchecked Exception (null pointer exception)

Có 2 cách ném Exception: 
	ném exception ngay tại đầu hàm (khi truyền vào dữ liệu ko hợp lệ -> xử lý throw exception được) 
	try..catch (khi truyền vào dữ liệu ko hợp lệ -> ko xử lý throw exception được) -> throw exception mặc định
	-> 2 trường hợp này dùng với throw -> nó sẽ chỉ hiển thị lỗi ở Terminal ko hiển thị ra màn hình được -> cần sử dụng cái nào trả ra ResponseEntity(customize phần pản hồi ra client)

	@ExceptionHandler dùng để trang trí cho 1 hàm (như 1 listener) mỗi lần xảy ra ngoại lệ (khi throw ra exception nào mà exception đó được gán vào value của @ExceptionHandler) -> sẽ chạy vào hàm này + ResponseEntity để trả customized exception cho Client 
		@ExceptionHandler(value = IdInvalidException.class)		
		public ResponseEntity<String> handleIdException(IdInvalidException idInvalidException) {	
			return ResponseEntity.badRequest().body(idInvalidException.getMessage());
		}
	khi dùng dùng @Annotation này -> khi gặp lỗi cần throw trực tiếp thì nó mới chạy vào hàm xử lý của Annotation này - nếu dùng try..catch thì nó sẽ ko chạy vào
	Khi throw trực tiếp (ko dùn try..catch) thì đầu hàm phải có throws ...Exception nếu ko sẽ bị lỗi 

Tồn đọng: khi khai báo như trên bên trong UserController.java
(1) phạm vi hoạt động của function(@ExceptionHandler) chỉ nằm trong UserController -> cần định nghĩa khác để linh hoạt hơn
(2) hiện tại khi tham số truyền vào là 1 chuỗi String -> nó sẽ ko chạy vào throw bên trong hàm mà sẽ throw ở ngoài hàm = exception mặc định -> cần xử lý bên ngoài bắt ngoại lệ bên ngoài controller đó tức là bug ko nằm trong phần body hàm mà xảy ra lúc convert ở các tham số khi truyền vào của hàm
	Cách 1: valid ở frontend 
	Cách 2: chuyển kiểu dữ liệu thành String -> valid ở backend 

			Mô hình Spring Request Response 
client --request--> controller 
				----> local Exception (khai báo @ExceptionHandler bên trong 1 file java) --crash--> client
				----> globle Exception 
	local Exception -> chỉ dùng được trong 1 file 
	-> cần chuyển nó ra thành globle Exception để dùng trong nhiều trường hợp để làm thì ta có 1 khái niệm gọi là AOP là 1 khái niệm chia cắt ứng dụng thành các thành phần ko quan hệ với nhau (các thành phần độc lập)

Giới thiệu về AOP
https://docs.spring.io/spring-framework/reference/core/aop.html

Tham khảo: https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/tree/master/src/main/java/com/mycompany/myapp?ref_type=heads
-> trong github này họ làm cho logging aop/logging trong này họ dùng các Annotation rất đặc biệt như @Aspect, @PointCut, ... dự án này sẽ dùng ControllerAdvice là 1 ứng dụng của AOP để can thiệp vào quá trình xử lý trước khi trả về phản hồi cho người dùng + ko tập trung code tại 1 file mà nó sẽ chịu trách nhiệm tất cả các file còn lại 
				

Xử lý (1):  @ControllerAdvice

-  Spring @ControllerAdvice https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html

Được giới thiệu từ version Spring Framework 3.2
Xử lý @ExceptionHandler, @InitBinder, or @ModelAttribute được chia sẻ tại tất cả controller trong ứng dụng MVC
Cũng có thể làm tương tự cho RESTful, tuy nhiên cần @ResponseBody

@ResponseBody giúp convert Response trả về dưới dạng JSON
Ví dụ 1: Xử lý với MVC
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(value = Exception.class)
   public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {
        ModelAndView mav = new ModelAndView();
        mav.addObject("exception", e);
        mav.addObject("url", req.getRequestURL());
        mav.setViewName("error");
        return mav;
    }
}
-> cấu hình và response ra view cho người dùng

  Ví dụ 2: Xử lý với RESTful  
// Handle custom exceptions across the application
    @ExceptionHandler(CustomException.class)
    @ResponseBody //phần cần thêm để có thể sử dụng ResponseEntity<T> phía dưới nếu k có ko dùng được  
    public ResponseEntity<?> handleCustomException(CustomException ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
                HttpStatus.BAD_REQUEST.value(),
                ex.getMessage(),
                request.getDescription(false));
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

Có 1 cách nữa để sử dụng với RESTFul, là sử dụng  @RestControllerAdvice

@RestControllerAdvice được giới thiệu từ version 4.3

https://docs.spring.io/spring-framework/docs/4.3.9.RELEASE/javadoc-api/org/springframework/web/bind/annotation/RestControllerAdvice.html

So sánh @RestControllerAdvice và @ControllerAdvice: 
https://stackoverflow.com/a/43124517

@RestControllerAdvice = @ControllerAdvice + @ResponseBody

@ControllerAdvice dùng được cho Spring MVC + Restful API (kèm theo dùng @ResponseBody)
@RestControllerAdvice chỉ dùng cho Restful API (ra đời sau)
	
2 Annotation này sẽ can thiệp vào ném ra Exception @ExceptionHandler, khởi tạo giá trị @InitBinder, gán giá trị cho ModelAttribute @ModelAttribute -> can thiệp vào quá trình xử lý đây cũng là 1 Ứng dụng của AOP

##II - Format Response before Sending (Part 1)##

Tài liệu: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseBodyAdvice.html

1.Ví dụ về API trong thực tế

Việc viết API này -> phục vụ cho dự án + đối tác (đồng nhất theo 1 chuẩn)

https://developers.momo.vn/v2/#/docs/query_status

Một kết quả trả ra của API, luôn cần có:
Status code : 200, 201, …
Message : miêu tả nếu có
Data : nếu có

Mỗi 1 công ty có 1 quy định khác nhau về format của phản hồi, tuy nhiên, tối thiểu API cần cung cấp 3 thông tin trên

Mục tiêu: Trả về response theo format định sẵn
Trường hợp thành công:
{
  statusCode: " ", //200 404
  message: " ",
  data: " "
}

Ví dụ:
{
    "statusCode": 201,
    "message": "User Login",
    "data": {
        "access_token": "",
        "user": { }
    }
}

Trường hợp lỗi : 
{
    "message": " ",
    "error": " "
    "statusCode":" ",
}
Ví dụ: {
    "message": "Username/password không hợp lệ!",
    "error": "Unauthorized",
    "statusCode": 401
}


2.Format Response

Cách 1: sử dụng local với ResponseEntity -> gửi dữ liệu về client
https://stackoverflow.com/a/44840010
-> nhược điểm: ko linh động cần thêm thủ công -> có bao nhièu API pải thêm bấy nhiêu ResponseEntity

Cách 2: sử dụng global với Controller Advice
https://stackoverflow.com/a/52104852
-> linh động hơn ~ như xử lý Exception 

Bước 1: Định nghĩa format object

public class RestResponse<T> {
    private int statusCode;
    private String error;

    // message có thể là string, hoặc arrayList
    private Object message;
    private T data;

}


Bước 2: Sử dụng ControllerAdvice
https://stackoverflow.com/a/51551663

@ControllerAdvice
public class FormatRestResponse implements ResponseBodyAdvice<Object> {
	
//đây là 2 method buộc override của interface ResponseBodyAdvice
    @Override
    public boolean supports(
        MethodParameter returnType, 
        Class converterType
    ) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(
    Object body, 
    MethodParameter returnType, 
    MediaType selectedContentType,
    Class selectedConverterType,
    ServerHttpRequest request, 
    ServerHttpResponse response
) {
    
                // Check if the status code represents an error
        if (status >= 400) {
            //case error
        } else {
            //case success
        }
    }
}

- ở hàm supports có ý nghĩa cấu hình khi nào muốn ghi đè - khi nào format phản hồi của API 
	-> return về true bất cứ phản hồi nào cũng ghi đè
	-> sau này muốn check cho từng controller thì ghi logic vào đây
	
	-> return false thì nó sẽ ko format 

- hàm beforeBodyWrite được chạy khi hàm supports trả về true 
	Object body: là phản hồi chưa format
	request: lời gọi từ client -> server 
	response: thông tin trả về từ server -> client 
	-> muốn lấy trạng thái của pản hồi pải thông qua response
	
	Nhưng đối với response thông thường -> sẽ không lấy về được status code cần ép kiểu nó về HttpServletResponse 
	HttpServletResponse servletResponse = ((ServletServerHttpResponse)response).getServletResponse();

- cấu hình lại phần response:
	int status = servletResponse.getStatus();

        RestResponse<Object> restResponse = new RestResponse<Object>();
        restResponse.setStatusCode(status);
        if (status >= 400) {
            // case error
            restResponse.setError("CALL API FAIL");
            restResponse.setMessage(body);
        } else {
            // case success
            restResponse.setData(body);
            restResponse.setMessage("CALL API SUCCESS");
        }
        return restResponse;

Tới đây nếu test api truyền sai dữ liệu lên -> vẫn chưa hoạt động đúng vì nó sẽ chạy ResponseBodyAdvice<Object> trong FormatRestResponse.java trước khi chạy vào GlobalException.java có 2 cách để xử lý thứ tự:
	- dùng Annotation Order 

- Khi cấu hình xong class này thì mọi phản hồi từ Server -> Client để sẽ chạy vào đây chứ ko phải phần return của từng API nữa 

3 - Cấu hình Phần Globla Exception + Global Response: dùng @ControllerAdvice, @ResponseBody || @RestControllerAdvice
- Khi gọi API thành công -> chạy vào controller -> đến return ResponseEntity.status(HttpStatus.OK).body(this.userService.fetchUserById(id)); -> chạy sang FormatRestResponse(globla Response chạy qa 2 hàm supports -> beforeBodyWrite) -> response về cho client

- Khi gọi ko thành công -> chạy vào throw new IdInvalidException("user ko ton tai"); -> chạy vào class IdInvalidException -> chạy vào GlobalException.java -> FormatRestResponse (Global Response chạy qa 2 hàm supports -> beforeBodyWrite) -> response về cho client

** tất cả test cho API /users/{id} với kiểu kiểm tra đơn giản là id có tồn tại hay ko **

====Chapter 7: Spring Security với Json Web Token====
**Bảo vệ APIs với cơ chế JWT của mô hình Stateless

##I - Mô hình Stateful và Stateless##
Tương tự khi so sánh Monolithic và Microservice

1.Keyword hay gặp
Lưu ý 1: Không nên dịch nghĩa, thay vào đấy là nên “cảm nhận” ý nghĩa của nó.
Lưu ý 2: các dịch nghĩa bên dưới mang tính chất tương đối. Bạn có thể google để xem “cách định nghĩa” chính xác nhất.

Stateful = state application + full : chứa đầy state của application
Lưu trữ thông tin bên trong ứng dụng, ví dụ như thông tin người dùng đăng nhập
	Session : phiên đăng nhập. Được dùng trong mô hình Stateful, cách mà ứng dụng lưu trữ data giữa các lợi gọi request

Stateless = state application + less : không chứa state của application
Không lưu trữ thông tin trong ứng dụng (nothing at all)

Monolithic: (architecture) all-in-one : bạn code tất cả mọi thứ trong 1 dự án. Ví dụ như mô hình MVC truyền thống tự code controller, model, view, ... all things chỉ nằm trong 1 dự án java 

Microservice: (architecture): single-unit : bạn chia code thành các “thành phần riêng lẻ” (module/service), mục đích là giảm sự phụ thuộc giữa các thành phần, và tăng tính mở rộng


2. Stateful và Stateless

Stateful = Monolithic (Spring MVC)

Stateless = Microservice (Restful API)

Không có khái niệm Monolithic hay Microservice tốt hơn, cái nào cũng có ưu và nhược điểm của nó. Việc bạn cần làm, là lựa chọn công nghệ sao cho nó “phục vụ tốt với mục đích của bạn”

3.Tại sao chúng ta chọn Stateless thay vì Stateful (khóa MVC - Monolithic) ?

- Sử dụng RESTful API, thông thường (hay dùng nhất) là áp dụng cho mô hình Stateless.
- Có nghĩa rằng, bạn sẽ chia tách code thành Frontend và Backend riêng lẻ (không phụ thuộc vào công nghệ)

Ví dụ:
Frontend:  bạn code với Angular/Vue/React. 
Hoặc thậm chí chỉ là HTML, CSS, Javascript (AJAX)

Backend: sử dụng bất cứ ngôn ngữ backend nào bạn muốn, như Javascript, Java, PHP…
Javascript : Express, Nestjs…
Java: Java Spring
PHP: Laravel
C# : .Net
Python: Django
Ruby: Ruby on Rail …

- RESTful API là cầu nối giữa frontend và backend. Điều này lý giải:
	+ Frontend sẽ không thể thao tác với database (CRUD dữ liệu), mà cần làm gián tiếp qua API
	+ Backend sẽ không cần code giao diện, chỉ thực hiện nhiệm vụ thao tác với dữ liệu (lưu trong database) và tạo ra API cho frontend dùng. 
- Chúng ta đang làm nhiệm này (tạo ra RESTful API)

4. Cơ chế xác thực của Stateless
Trong mô hình Stateless, không tồn tại khái niệm “Session”, thay vào đấy là “Token”

- Cơ chế xác thực dựa vào Session (Stateful)
	Bước 1: login với username/password
		Nếu login thành công, server sẽ tạo lưu thông tin tại: Client thông qua cookies (lưu SESSION_ID)
		Server trong memory (RAM) hoặc database (lưu full thông tin của user login)

	Bước 2: Mỗi lần người dùng F5 (refresh) website gửi 1 request  từ client lên server, các bước làm tại Server:
		Client sẽ gửi kèm SESSION_ID (thông qua cookies)
		Server sẽ kiểm tra SESSION_ID có đang tồn tại hay không ? Nếu có, tiếp tục việc truy cập như thông thường (else, logout)

Mô hình Stateful với Session chỉ áp dụng hiệu quả, khi và chỉ khi bạn kiểm soát cả frontend và backend

Nhược điểm: chỉ giao tiếp giữa client và server -> nếu muốn viết ứng dụng cho mobile, desktop, đối tác, ... (server -> server) -> cần mô hình Stateless để giải quyết 

- Cơ chế xác thực dựa vào Token (Stateless)
với mô hình này t ko kiểm soát all thông tin 
Server với Server, mobile app, desktop app…  (những cái không có cookies)

Token: là 1 chuỗi ký tự đã được mã hóa (chỉ Server mới có thể hiểu) 
Ví dụ: adfasdfasdfasdfxyadfyajsdfasdfad
có 1 cơ chế sinh token: JSON Web Token

Bước 1: login với username/password
Nếu login thành công, server sẽ tạo token, lưu tại đâu, client tự quyết định.
Server không lưu bất cứ thông tin gì về việc user login 

Bước 2: Mỗi lần người dùng F5 (refresh) website gửi 1 request  từ client lên server, sẽ cần gửi kèm token đã có tại bước 1.
Server sẽ giải mã token để biết được user có hợp lệ hay không ?

##II - JSON Web Token (JWT)
Tài liệu:
https://jwt.io/

1.JWT là gì ?
https://jwt.io/introduction
- cho phép tạo 1 chuỗi kí tự ngẫu nhiên 
- Là một chuỗi ký tự được “mã hóa” (thông qua thuật toán) và có tính bảo mật cao.
- Được sử dụng để trao đổi thông tin giữa các hệ thống với nhau (server - server, client - server)

2. Cấu trúc của JWT
Gồm: 
	Header: quy định thông tin của token: thuật toán sử dụng, ...
	Payload (đây là cái chúng ta quan tâm nhất): data chứa trong token, thông tin định danh của người dùng (không có lưu mật khẩu)
	Signature: giúp tăng thêm độ mạnh mẽ, bảo mật của token như đặt mật khẩu để giải mã token 
ba thông tin này ngăn cách nhau bởi dấu chấm 

-> dùng đến Spring Security - cấu hình nó 
- ở Spring MVC để đăng nhập chúng ta cấu hình provider:
	+ DaoAuthenticationProvider
	+ third party thì dùng: OidcAuthenticationProvider, OAuth2AuthenticationProvider

đối với dự án này sẽ tìm hiểu về JwtAuthenticationProvider

##III - Cơ chế mặc định của Spring Security##

Tạo class config/ConfigConfiguration.java -> để biến class này thành cấu hình -> dùng Annotation Configuration dùng cái này khi ứng dụng chạy nó sẽ dùng component scan nó sẽ quét all component đối với component nào có Annotation Configuration nó sẽ đưa vào phần cấu hình việc code trong class có Annotation này sẽ ghi đè lại các cấu hình mặc định của Spring kế từ Version 5.8 sẽ dùng qa Bean chứ ko kế thừa các interface cần thiết

Ngoài Annotation configuration còn có EnableMethodSecurity: 
	có nhiều level để xác thực người dùng: mỗi 1 lần gửi request lên phía server -> cần xác thực hoặc xác thực tại lớp method 

đối với dự án ban đầu đã disable phần Security: ở file main
//disable security
@SpringBootApplication(exclude = {
		org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class,
		org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration.class
})
// @SpringBootApplication

1. Cấu hình Password Encoder: https://drive.google.com/file/d/1g8vEafVNLmO63V_2RrOmQQDTi8NMkMds/view
- ghi đè phần mã hóa password của Security
- để mã hóa mật khẩu của người dùng

//todo : hoàn thiện tính năng CREATE user với hash Password
passwordEncoder.encode()
admin@gmail.com abc
user@gmail.com abc
thtrong@gmail.com abc

2. Enable Security 
- vào file main file đầu tiên ứng dụng chạy lên
- comment cái disable security đi và enable cấu hình mặc định lên 
- sau khi enable nó lênn nó sẽ cấu hình mặc định rất nhiều lớp filter pải đi qa trước khi đến với các endpoint của controller 
(lúc này khi vào postman gửi request -> lỗi 401 unauthorized)
- mặc định nó đã bảo vệ all endpoint, tài nguyên nếu muốn truy cập -> cần đăng nhập 
- lúc này khi truy cập ứng dụng qa browser -> thì sẽ bị văng về trang login (dùng cho mô hình MVC stateful) nhưng đối với ứng dụng này dùng mô hình stateless tức là dùng JWT để truy cập -> ko cần form login này 

- tiếp theo cần cấu hình thêm phần security để có thể truy cập vào được một số url: cấu hình http cần ghi đè lại 1 phần cấu hình tên là SecurityFilterChain 
	+ những API gửi lên server thực tế là 1 lời gọi của http -> cần cấu hình http.authorizeHttpRequests
		đầu tiên enable session lên: 
		.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
		bởi vì mặc định spring Security theo mô hình STATEFUL -> trong pần session pải cấu hình lại STATELESS
	+ phần cấu hình mặc định hiển thị ra trang login, hay đăng nhập = basic form, truy cập mọi endpoint pải cần xác thực ... nằm ở class SpringBootWebSecurityConfiguration.class nhưng trong ứng dụng này dùng JWT -> override lại 

##IV - OAuth Flow##

hiểu tổng quan để tự viết một vài Filter -> để khi client gửi request lên server pải đi qa filter này nhiệm vụ của filter này sẽ giải mã token mà client gửi lên 
chức năng của filter: 
	lấy JWT token từ header mà người dùng gửi lên 
	load user lên -> ghi đè lại pần này 
	cần validate token (viết thêm 1 service để giải mã/validate, mã hóa, tạo,... token)
	cuối cùng nạp vào SecurityContextHolder 

1. Lưu ý về cách code JWT với Spring

KHÔNG LÀM NHƯ CÁC VÍ DỤ BÊN DƯỚI: ĐÂY LÀ CÁCH CODE CHO CHẠY ĐƯỢC, KHÔNG PHẢI LÀ CÁCH CÔNG TY LÀM, VÌ NÓ TIỀM ẨN RỦI RO VỀ SECURITY

https://www.geeksforgeeks.org/spring-boot-3-0-jwt-authentication-with-spring-security-using-mysql-database/

https://www.youtube.com/watch?v=KxqlJblhzfI

Giải thích quy trình code cho chạy được:

Bước 1: Cài đặt các thư viện hỗ trợ JWT (encode/decode)
Bước 2: Viết Filter (tạm gọi là jwtFilter) để xử lý cho JWT
Filter này sẽ được chạy trước khi Spring Security xử lý (chạy các Filter khác)

jwtFilter sẽ có nhiệm vụ decode/verify (giải mã và xác thực tính hợp lệ) của JWT mà client truyền lên

2. OAuth là gì ?

Để mở rộng mô hình và chuyển sang mô hình kiểu service (các client, server, service,... có thể kết nối/sử dụng dịch vụ được) -> Spring sử dụng giải páp sử dụng tiêu chuẩn OAuth (open auhthorization) 

OAuth (open auhthorization) tức là việc xác thực người dùng ntn, người dùng có quyền hạn ntn sử dụng rộng rãi trong mô hình Microservice 

Tham khảo: 
https://www.youtube.com/watch?v=ZV5yTm4pT8g
https://www.youtube.com/watch?v=ZDuRmhLSLOY

OAuth (Open Authorization) là một chuẩn (standard) dùng để xác thực thông tin người dùng thông qua token. (từ 2012)
Tham khảo (v2.0): https://datatracker.ietf.org/doc/html/rfc6749

Được ứng dụng rộng rãi trong mô hình stateless (microservice) khi một ứng dụng liên quan tới nhiều dịch vụ (service)

Các vai trò (role) khi sử dụng OAuth:
Resource Owner : người sử hữu nguồn tài nguyên, thông thường chính là User - người sở hữu tài khoản của họ.  Ví dụ, bạn là chủ sở hữu của tài khoản Facebook do bạn tạo ra

Resource Server: nơi hosting dữ liệu của người dùng. Ví dụ, tài khoản Facebook của bạn sẽ được lưu trữ tại server nào đó do Facebook Quản lý

Client: Ứng dụng muốn truy cập/sử dụng thông tin của người dùng

Authorization Server: nơi chịu trách nhiệm tạo ra access-token để cho Client sử dụng Resource Server (sau khi đã được Resource Owner cho phép)

Ví dụ:
https://www.codeproject.com/Articles/1171546/OAuth-Authorization-flows-explained-with-examples
như vào github thực hiện chức năng đăng nhập với Google: 
	Resource Owner là người dùng người sở hữu tài khoản Google là người có quyền cấp phép 
	Resource Server là server của Google
	Client: là trang Github
	Authorization Server nó là của Google bởi vì chỉ có Google mới biết thông tin tài khoản đăng nhập được nhập vào có đúng hay không -> khi bấm vào đăng nhập thì quá trình Authorization nó sẽ xảy ra tại Google tại Authorization Server nó sẽ kiểm tra và nếu đúng nó sẽ trả lại thông tin cho Client(Github) như AccessToken 
	khi có AccessToken Client sẽ Query trực tiếp đến Resource Server để lấy tài nguyên

##V -  Spring và OAuth##
Hướng dẫn tích hợp OAuth

1. Lịch sử ra đời và sử dụng với Spring

Spring là 1 Hệ Sinh thái (Frame Work): Spring Security nếu nói ở trong Frame Work Spring thì là thư viện nhưng với mô hình của nó có thể nói nó là 1 Frame work khác

- Trước 2022: Spring Security OAuth
https://spring.io/blog/2022/06/01/spring-security-oauth-reaches-end-of-life
dự án này end of life: ko được pát triển nữa -> đưa ra 2 sự lựa chọn 
	+ sử dụng tính năng có sẵn của Spring Security(OAuth 2.0) ra đời khi vừa có Spring Security về ưu điểm là đã tích hợp sẵn trong Spring Security -> ko cần cài thêm gì và có thể giải quyết vấn đề, nhược khó bảo trì vì nó liên quan qá nhiều tới Spring từ trước đến nay -> ko thể linh hoạt khó thay đổi chỉnh sửa nhiều (theo mô hình Statefule)
	-> nếu mún sử dụg với nhu cầu nhỏ, ko thay đổi nhiều nên sử dụng của Spring Security
	Đối với ứng dụng này sẽ dùng cái này chứ ko dùng cái mới 

	+ sử dụng dự án Spring Authorization Server (1 thư viện/Frame work khác của Spring) cái này là cái cập nhật cho công nghệ OAuth2 mới nhất (OAuth 2.1) ra đời năm 2022 ưu điểm ko phụ thuộc vào cái gì cả và luôn cập nhật cái mới nhất (theo mô hình Stateless đang tách riêng ra) -> ko dính nhiều tới các dự án Spring khác -> có thể thay đổi linh hoạt 
	-> nếu mún controll hết, thay đổi linh hoạt, update nhanh mới nên dùng thư viện/frame work mới này 

2 cái này chính là tác nhân Authorization Server trong mô hình OAuth2 

https://github.com/spring-attic/spring-security-oauth
dự án này đag ở trạng thái publish archive: là trạng thái hoàn thành rồi + ko được bảo trì nữa -> nếu có bugs hoặc công ngệ mới sẽ ko được cập nhật 
-> cân nhắc khi sử dụng 

- Sau 2022 : có 2 dự án (project) nổi bật hỗ trợ OAuth là:
Spring Security (hỗ trợ OAuth 2.0) là 1 tính năng tích hợp sẵn 
https://docs.spring.io/spring-security/reference/6.1/servlet/oauth2/index.html
Khi làm Spring MVC vào link này chỉ đụng tới Authentication + Authorization chứ chưa đụng vào package OAuth2 -> đây sẽ là pần làm trong ứng dụng này (nằm trong Spring Security) trong package này sẽ sử dụng OAuth2 Resource Server bởi vì hiện tại ứng dụng sẽ xác thực người dùng + tạo token nên pải dùng pần này, ko sử dụng OAuth2 Client vì cần request tới 1 nơi nào đó để lấy token trong khi ứng dụng tự tạo token chứ ko lấy từ Client nào (nếu muốn làm thủ công pải + 1 dự án java nữa để làm pần này), nếu muốn làm login cho gg hoặc face -> cần code 1 ứng dụng giúp Authorization cho 2 app 

https://github.com/spring-projects/spring-security


Spring Authorization Server (hỗ trợ OAuth 2.1): đây cũng là 1 dự án khác Spring Security tạo ra để bảo vệ Endpoint (cùng cấp với Spring Security)
https://spring.io/projects/spring-authorization-server
https://github.com/spring-projects/spring-authorization-server

Spring Security: 
	Gắn liền với hệ sinh thái của Spring, gần như là default (cấu hình mặc định) khi liên quan tới việc Authentication/Authorization
	Một sự thay đổi nhỏ thôi, cũng có thể là breaking-change, khi có quá nhiều ứng dụng phụ thuộc vào nó. Cơ mà, tích hợp luôn OAuth thì quá tuyệt vời (all-in-one)

Spring Authorization Server: 
	Ra đời muộn hơn Spring Security (2022) : https://spring.io/blog/2022/11/22/spring-authorization-server-1-0-is-now-ga
	Up to date với Security, có nghĩa là cập nhật những cái mới nhất, ví dụ OAuth 2.1
	Là một dự án độc lập (base dự trên Spring Security)


2. Mô hình áp dụng
https://docs.spring.io/spring-security/reference/servlet/oauth2/index.html#oauth2-resource-server

- Cài đặt dependencies:
implementation("org.springframework.boot:spring-boot-starter-oauth2-resource-server")
Fix lỗi không cài đặt dependency:
Bước 1: thêm dependency vào file build của gradle (lưu ý là trong video mình có yêu cầu thay đổi, vì lúc quay video mình có bug)
	implementation("org.springframework.boot:spring-boot-starter-oauth2-resource-server")
Bước 2: nhấn chuột phải vào file build.gradle.kts => chọn Reload Projects

- Với OAuth2, chúng ta cần:
	Auth Server (Authentication/Authorization): nơi xác định người dùng có tồn tại hay không  ? Nếu có,  người dùng có quyền hạn gì sau khi đã xác thực/đăng nhập thành công)
	Resource Server : nơi chứa nguyền tài nguyên (data) mà người dùng muốn truy cập

Áp dụng vào bài toán của chúng ta: (cách làm đơn giản nhất)

Client : React

Server : Java Spring (chỉ có 1 server) - all in one
=> server này cần làm các nhiệm sau: (nơi cung cấp tài nguyên, tạo token, xác thực người dùng luôn)
	Xác thực người dùng (authentication): chức năng login. 
	Xác định quyền hạn của người dùng (authorization) : permission và role
	Sau khi đã xác thực và đảm bảo người dùng “phù hợp”, server cho phép client truy cập nguồn tài nguyên (thông qua api)

##VI - Login Flow##
1.Mô hình MVC
https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html

Mô hình chung: khi login nó sẽ chạy qa các filter chains kế thừa lại abstract AbstractAuthenticationProcessingFilter -> authentication -> authenticationManager (ở đây nó sẽ check dùng cơ chế gì để đăng nhập + authenticated ? thông tin đăng nhập):
	+ nếu đúng -> SessionAuthenticationStrateyg + SecurityContextHolder(*) + RememberMeServices + ApplicationEventPublisher + AuthenticationSuccessHandler (chủ yếu là lưu thông tin vào * để mình xử lý)
	+ nếu sai -> SecurityContextHolder + RememberMeServices + Authentication (ném ra exception)


- đối với ứng dụng này:
Khi bạn nhấn nút login, sẽ gửi request lên server và trigger filter.
khi đăng nhập = username + password -> Filter được gọi ở đây là UserNamePasswordAuthenticationFilter trong này lần lượt gọi tới: 	
	UsernamePasswordAuthenticationToken(1)
	AuthenticationManager - pần này nó sẽ là phần gọi authenticate() (2)
		ProviderManager
		DaoAuthenticationProvider(Provider xử lý trường hợp đăng nhập = username và password) đối với Provider này có function: UserDetails loadUserByUsername(String username)

	-> success -> tương tự như mô hình chung là lưu thông tin vào SecurityContextHolder 
	-> Fail -> throw exception

Ở đây có 1 vấn đề: đối với mô hình stateless ko hề có form login khi đăng nhập -> k thể trigger phần Security được bởi vì ko có function nào gọi trực tiếp đến UserNamePasswordAuthenticationFilter -> thay vì vậy t sẽ tự tạo chay từng thành pần:
	(1) -> tự tạo token 
	(2) -> tự gọi đến phần AuthenticationManager -> gọi hàm authenticate() 
	-> đăng nhập success -> tự lưu thông tin vào SecurityContext 


2. Đối với Mô Hình Stateless - các bước thực hiện vấn đề trên
Bạn không có form login để trigger filter, thay vào đấy là API endpoint.
Bước 1: bạn submit api với username/password

Bước 2: Spring sẽ không trigger Filter nào hết, mà sẽ chạy thẳng vào controller, nơi bạn định nghĩa endpoint (vì cơ chế JWT là cơ chế không được xây dựng sẵn của Spring)

=> chúng ta cần viết logic để xử lý đăng nhập người dùng (kế thừa tương tự logic của UserNamePasswordAuthenticationFilter )
Why ?
Vì khi làm theo luồng của Spring Security, chúng không cần bận tâm về quá trình so sánh mật khẩu user và nạp thông tin user vào Security Context (đế tái sử dụng - tương tự như Session)

//tạo token với username và password được nạp lên từ client 
 UsernamePasswordAuthenticationToken authenticationToken 
= new UsernamePasswordAuthenticationToken(username, password) 

//truyền token vào authenticationManagerBuilder (chính là bước ở AuthenticationManager)
//authenticate() -> xác thực password và username gửi lên có đúng hay ko gián tiếp thông qa token
Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);

//-> sau khi ở AuthenticationManager -> cần authenticated -> gọi đến UserDetails LoadUserByUserName(String username) -> cần override lại: ở đây sẽ giải mã token -> lấy user từ database lên so sánh 

//nạp thông tin (nếu xử lý thành công) vào SecurityContext để tái sử dụng thông tin của người dùng giữa các lời gọi request ở mô hình stateless ko sử dụng session -> bây h muốn từ controller gọi đến services -> bên trong services cần lấy thông tin của người dùng thì sẽ lấy từ SecurityContext này 
 SecurityContextHolder.getContext().setAuthentication(authentication);
 String jwt = this.createToken(authentication);

Tham khảo: https://drive.google.com/file/d/1Goo_ejUCnyahSGpxTTp4S0yKt5oQdhhM/view

##VII - loadUserByUsername##

ở đây chỉ mới xác thực thông tin người dùng xem thông tin đăng nhập có hợp lệ ko chưa hề đụng tới token 



Bước 1: Tạo DTO class 
username: String
password: String

Bước 2: tạo AuthController 
	disable formlogin mặc định của Security
	disable cơ chế csrf -> nếu ko khi dùng endpoint dạng login method post sẽ lỗi 403 + với mô hình stateless cũng ko dùng token này 
Tạo endpoint: /login

//Nạp input gồm username/password vào Security
 UsernamePasswordAuthenticationToken authenticationToken 
= new UsernamePasswordAuthenticationToken(username, password)

//xác thực người dùng => cần viết hàm loadUserByUsername
Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);
	với authenticationManagerBuilder được tiêm vào và lệnh này nếu để pure như này sẽ bị lỗi -> cần hiểu cơ chế của Spring Security nó xác thực người dùng ntn mặc định nó sẽ lưu người dùng vào Memory chứ k biết mình lưu người dùng vào Database (Memory chỉ có 1 trên máy người dùng, SQL có nhiều loại -> cần nói cho nó biết lưu ntn ở đâu) -> cần viết lại hàm loadUserByUserName trong này 

//nạp thông tin (nếu xử lý thành công) vào SecurityContext
 SecurityContextHolder.getContext().setAuthentication(authentication);

Bước 3: Viết Service UserDetail loadUserByUsername(String username) 

tạo class UserDetailsCustom implements UserDetailsService trong interface UserDetailsService chỉ có 1 hàm loadUserByUsername(String username) với username chính là username gửi từ client lên dùng để query user sau khi lấy được user từ database -> hash password gửi từ client so sánh với password đã hash từ user vừa lấy lên từ database (quá trình so sánh này sẽ được spring tự động làm) nhiệm vụ cần làm:
	tìm người dùng bên tron database -> truyền password hash từ người dùng này vào cho spring 

- để cho Spring biết được mình đag viết class UserDetailsCustom ghi đè lại UserDetailsService: 
	+ đối với mô hình MVC cần cấu hình lại config/SecurityConfiguration.java: ghi đè nạp nó nào 
	+ Nhưng đối với ứng dụng này t sẽ làm level cao hơn = cách ghi đè = tên của @Bean cơ chế: mặc định nếu ko định nghĩa tên của Bean -> nó sẽ dùng tên của kiểu trả về của function bên dưới các @Bean -> convert tên đối tượng đó mặc định nó sẽ biến chữ tiên thành chữ thường đây là quy tắt đặt tên Bean của Spring sẽ lấy tên đối tượng đã được chuyển đối -> làm tên của Bean đó
	-> thay vì việc cấu hình trực tiếp thì mình sẽ cấu hình gián tiếp thông qua tên của Bean 
	-> ko cần cấu hình bên trong config/SecurityConfiguration.java mà chỉ cần thêm @component("userDetailServices") vào trc class UserDetailsCustom 

//lưu ý: xử lý custom exception (nếu sai mật khẩu/email) 
Tham khảo https://www.google.com/url?q=https://github.com/hoidanit-be-java-spring-rest/02-java-jhipster-with-filter/blame/master/src/main/java/com/mycompany/myapp/security/DomainUserDetailsService.java?ref_type%3Dheads%23L20&sa=D&source=docs&ust=1739851688233574&usg=AOvVaw3SBTxMcTlrA3I_OlLPKUot

Về cách đặt Bean Name:
https://stackoverflow.com/a/53758500

nhiệm vụ cuối cùng là trả ra UserDetails theo đúng kiểu trả về của function loadUserByUsername(String username) -> giống Spring MVC sẽ dựa vào tính đa hình của Spring -> sẽ return về User của Spring Security vì class này có implements UserDetails
        return new User(
                user.getEmail(),
                user.getPassword(),
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));

##VIII -  Debug Code (Extra)##
1.Xử lý Exception
Validate dữ liệu username/password (không được để trống)

Validate trường hợp username/password đã truyền lên, nhưng không hợp lệ, bao gồm email không tồn tại/hợp lệ và sai password

Advance: handle tất cả exceptions, tham khảo https://drive.google.com/file/d/1j5IikoDtR9de0Mw-1QkH41_gCMCZ62FJ/view

//hiện tại, chưa xử lý exception của security (sẽ được xử lý cùng với việc validate jwt)
https://www.baeldung.com/spring-security-exceptionhandler

2.Luồng Debug

Kỹ năng debug: https://code.visualstudio.com/docs/editor/debugging

Debug từ ban đầu: khi dùng postman gửi request -> api: /login 
- đặt debug và dừng tại: UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
                loginDTO.getUsername(), loginDTO.getPassword()); trong controller url: /login 
	Step into: chạy vào loginDTO getUsername(), getPassword() -> chạy đến hàm tạo UsernamePasswordAuthenticationToken() -> gọi đến super() cha của nó AbstractAuthenticationToken .... sau khi xử lý xong phần cha -> qay lại gán giá trị principal = username, credentials = password... trong hàm khởi tạo sau đó qay về lại controller /login chạy đến lệnh kế tiếp trong controller

- tiếp theo đặt debug và dừng tại: Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken); dùng step into đầu tiên chạy vào pần xử lý của .getObject()... sau đó chạy vào authenticate() -> chạy vào hàm authenticate() của ProviderManager (thực chất hàm authenticate() này là của interface authenticationManager mà class ProviderManager kế thừa lại và được thực thi lúc này) trong hàm authenticate() này nó sẽ chạy vào vòng lặp để chọn ra Provider thích hợp đối với dự án hiện tại size của vòng lặp = 1 tức là chỉ có 1 Provider được xét vì đăng nhập = username và password chính là DaoAuthenticationProvider nếu bên trong phần config/SecurityConfiguration.java có cấu hình thêm phần đăng nhập khác (như đăng nhập dùng third party) thì size sẽ tăng lên và số lượng provider được cung cấp để scan cũng nhiều lên hiện tại chỉ cấu hình đơn giản/mặc định là đn = username, password... cứ step into sẽ tới 1 bước nó xử lý phần token mình gửi vào hàm authenticate() lấy ra principal(email) thông qua hàm getPricipal() của class UsernamePasswordAuthenticationToken ...

- tới bước trên cứ step into cho nó xử lý việc lấy và kiểm tra principal cuối cùng nó sẽ chạy vào function retrieveUser() bên trong DaoAuthenticationProvider trong này nó có kiểm tra việc hash password = cách nào (hiển thị cấu hình bên trong /config/SecurityConfiguration) cứ step into có phần hash phần password gửi từ client vào ... chạy các kiểu trong hàm retrieveUser() đến UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); username lúc này chính là email từ client gửi lên -> khi step into nó sẽ chạy vào loadUserByUsername(username) cái mà mình đã customize UserDetailsCustom là cấu hình để nó ghi đè lại cái mặc định, cứ step into cho đến return -> nó sẽ chạy lấy các thông tin sau đó vào hàm construct tạo ra User của Security cuối cùng là check các trường như accountNonExpired, accountNonLocked, credentialsNonExpired,... nhưng hiện tại khi khởi tạo mặc định nó sẽ = true hết nên sẽ pass khi check ...

- cuối cùng nó sẽ thực hiện xong function authenticate() -> trả giá trị về và qay lại controller (url: /login) và return ra ResponseEntity kết thúc 

Lưu ý: hiện tại luồng này chưa có nạp thông tin vào SecurityContextHolder

AuthenticationManager

ProviderManager (hàm authenticate)

=> quét ra DaoAuthenticationProvider

UserDetail

3. thực hiện bắt các Exception:
- khi người dùng nhập sai thông tin tài khoản hoặc ko nhập có điều chỉnh code
- ý tưởng sẽ xuất phát từ controller (tức là khi request gửi lên đã qua các filter vào được controller -> nếu có bất kì lỗi gì đều có thể bắt được - một số lỗi chưa tới controller nó đã bị -> chưa bắt được ở hiện tại)
- ở đây sẽ Validate thông tin gửi lên vào LoginDTO -> dùng @Valid để validate trực tiếp ngay bên trong model để dùng được nó thì cần cài dependency:
	implementation("org.springframework.boot:spring-boot-starter-validation")
- cách sử dụng: all annotation validate đều nhờ cài dependency package(jakarta.validation...)
	+ chỉnh lại đầu vào của controller thêm @Valid trước tham số cần kiểm tra: public ResponseEntity<LoginDTO> login(@Valid @RequestBody LoginDTO loginDTO)
	+ cấu hình cách validate trong model LoginDTO:
	@NotBlank(message = "username can't be blank")
    	private String username;

	@NotBlank(message = "password can't be blank")
    	private String password;
- khi làm đến đây -> khi chạy gửi lên thông tin lỗi nó vẫn sẽ gửi Exception mặc định của Security chỉ cấu hình sơ defaultMessage chính là cái message mình valid trong model 

- đọc phần trace của lỗi trên postman thì thấy bị exception: MethodArgumentNotValidException được ném ra -> cần cấu hình lại cái này cấu hình bên trong GlobalException.class:
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<RestResponse<Object>> validationError(MethodArgumentNotValidException ex) {
        BindingResult result = ex.getBindingResult();//dùng BindingResult để lấy ra message lỗi 
        final List<FieldError> fieldErrors = result.getFieldErrors();

        RestResponse<Object> res = new RestResponse<>();
        res.setStatusCode(HttpStatus.BAD_REQUEST.value());
        res.setError(ex.getBody().getDetail());
	// 3 dòng này để set các thông tin mặc định

        List<String> errors = fieldErrors.stream().map(f -> f.getDefaultMessage()).collect(Collectors.toList());
	//từ dạng list chuyển sang dạng stream thì mới dùng lamda được lấy ra all message sau đó convert người lại dạng List dùng collect gán nó lại vào 1 array String 
        res.setMessage(errors.size() > 1 ? errors : errors.get(0));
	//gán array lỗi nếu có hơn 1 lỗi thì gán nguyên array vào, ngược lại chỉ gán 1 chuỗi string 

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(res);
    }

- khi làm tới đây nếu trường hợp 1 trong 2 hoặc cả 2 username, password khi gửi request ko điền thông tin -> sẽ bắt được và xử lý lỗi 

- trường hợp ko bắt được: nếu nhập thông tin của username hoặc password sai -> sẽ throw ra exception BadCredentialsException mặc định ko bắt được vì nó lỗi trước khi mặc dù trong GlobalException.class có cấu hình bắt exception này -> nó chưa chạy vào đây nó đã bị lỗi 

- sẽ xử lý sau (thực tế có 1 số cách bắt all exception)



	















	















